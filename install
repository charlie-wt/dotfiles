#!/usr/bin/env bash

# install all the repo contents, & some other machine setup. aims to be idempotent.


# === Basic setup ======================================================================
d=$(dirname "$(readlink -e "$0")")  # directory of this script
root="$d"
source "$root/bash/_utils.bash"

# -y or -n options to always pick yes/no at prompts
default_choice=""
if [ "$1" = "-y" ]; then
    default_choice=true
elif [ "$1" = "-n" ]; then
    default_choice=false
fi


# === Symlinking dotfiles ==============================================================
# wrapper around `symlink`, specifically for dotfiles.
#
# $1: name of the file to link to (relative to $root).
# $2: (optional) name of symlink (absolute path). defaults to ~/.$1.
dotfile () {
    # params
    local dotfile_name="$1"
    local link_name="${2:-$HOME/.$dotfile_name}"

    symlink "$root/$dotfile_name" "$link_name" "dotfile $dotfile_name"
    return $?
}

title "symlinking dotfiles..."
dotfile bashrc
dotfile gdbinit
dotfile gitconfig       "$(config-home)/git/config"
dotfile kitty.conf      "$(config-home)/kitty/kitty.conf"
dotfile bash_profile
dotfile tmux.conf       "$(config-home)/tmux/tmux.conf"
dotfile vimrc
dotfile inputrc         "$(config-home)/readline/inputrc"
echo


# === Install scripts ==================================================================
# wrapper around `symlink`, specifically for scripts.
#
# $1: name of file to link to (relative to $root/scripts).
# $2: (optional) installed name of the script. defaults to that of the linked-to file.
install-script () {
    # params
    local script_path="$1"
    local script_name="${2:-$(basename "$script_path")}"

    local target="$root/scripts/$script_path"
    local link_name="$(bin-home)/$script_name"

    symlink "$target" "$link_name" "$script_path script"

    res=$?
    [ $res -eq 2 ] && >&2 echo "(looking in $root/scripts for scripts; have you set \$root correctly?)"
    return $res
}

title "symlinking scripts..."
install-script branched-from
install-script lightdark
install-script update-clangd
install-script update-kitty
install-script update-vim
echo


# === Other symlinks ===================================================================
title "making other symlinks..."
[ -d "$root/vim" ] && symlink "$root/vim" "$HOME/.vim/personal" "vim personal dir"
echo


# === Other bits =======================================================================
title "doing other misc stuff..."

# make directories for vim swapfiles & backups
mkdir -p "$(state-home)/vim/backups"
mkdir -p "$(state-home)/vim/swaps"
mkdir -p "$(state-home)/vim/undo"

# basic setup for vim plugin manager
vim_plug_loc="$HOME/.vim/autoload/plug.vim"
if [ -e "$vim_plug_loc" ]; then
    skip "plug.vim already exists in $vim_plug_loc"
else
    curl -fLo "$vim_plug_loc" --create-dirs \
        https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
    vim -c 'PlugInstall' -c 'qa!'
fi

# setup tmux plugin manager
tpm_dir="$(config-home)/tmux/plugins/tpm"
if [ -e "$tpm_dir" ]; then
    skip "tpm already exists in $tpm_dir"
else
    git clone https://github.com/tmux-plugins/tpm "$tpm_dir"
    . "$tpm_dir"/bin/install_plugins
fi

# basic rust setup
rustup_dir="$(data-home)/rustup"
cargo_dir="$(data-home)/cargo"
if [[ -e "$rustup_dir" && -e "$cargo_dir" ]]; then
    skip "rustup & cargo already exist in $rustup_dir & $cargo_dir"
elif confirm-action "do you want to install rust & cargo, via rustup?"; then
    export RUSTUP_HOME=$rustup_dir
    export CARGO_HOME=$cargo_dir
    curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y --no-modify-path
fi

# return 0 if an apt package is installed, else 1. will return 2 if apt isn't installed.
# $1: name of apt package to check.
is-apt-installed () {
    if ! have-cmd apt ; then
        return 2  # error
    fi
    local installed="$(apt list --installed "$1" 2>/dev/null | grep -v "^Listing" | wc -l)"
    if [ "$installed" -ge 1 ]; then
        return 0  # yes
    fi
    return 1  # no
}
if is-apt-installed rustc; then
    if confirm-action "$(warn-col rustc installed via apt): uninstall, to get via rustup instead?"; then
        sudo apt remove rustc
    fi
fi

# maybe install apt package
# $1: name of package to install
apt-install () {
    local installed="$(exit-code is-apt-installed "$1")"
    if [ "$installed" = 2 ]; then
        skip "apt not installed to install $1"
    elif [ "$installed" = 0 ]; then
        skip "$1 already installed"
    elif [ "$installed" = 1 ]; then
        if confirm-action "install $(info-col "$1") (via apt)?"; then
            sudo apt install "$1"
        fi
    else
        error "unknown error when apt installing $1 (is-apt-installed returned $installed)"
        return 1
    fi
}
apt-install python-is-python3
apt-install python3-pip  # note: needed for the later pipx stuff
apt-install python3-venv

# if a cargo package isn't installed globally, ask to install it
# $1: cargo package name
cargo-install () {
    if ! have-cmd cargo; then
        skip "cargo not installed to install $1"
    elif [ -n "$(cargo install --list | grep "^$1\s")" ]; then
        skip "$1 already installed"
    else
        confirm-action "install $(info-col "$1") (via cargo)?" && cargo install "$1"
    fi
}
cargo-install fd-find
cargo-install ripgrep

# pipx
if have-cmd pipx; then
    skip "pipx already installed"
elif have-cmd pip && confirm-action "install pipx?"; then
    PIP_BREAK_SYSTEM_PACKAGES=1 pip install --user pipx
fi

# if a pipx package isn't installed globally, ask to install it
# $1: pypi package name
pipx-install () {
    # TODO #bug: i think if pip was installed in this terminal session, `pip.bash` won't
    # have run to update the $PATH so `have-cmd pipx` will continue to fail. maybe
    # should put all the $PATH-updating stuff in `bash/` before the various guards...
    if ! have-cmd pipx; then
        skip "pipx not installed to install $1"
    elif [ -n "$(pipx list --short 2>/dev/null | grep "^$1\s")" ]; then
        skip "$1 already installed"
    else
        confirm-action "install $(info-col "$1") (via pipx)?" && pipx install "$1"
    fi
}
pipx-install python-lsp-server
pipx-install ranger-fm

# kitty theme
kitty_theme_dest="$(config-home)/kitty/theme.conf"
if [ ! -e "$kitty_theme_dest" ]; then
    symlink "$root/other/gruvbox/kitty/dark.conf" "$kitty_theme_dest" "kitty theme"
fi
echo

# TODO #enhancement: custom bash completions?


# === Local ============================================================================
title "doing local install..."

if [ -x "$root/local/install" ]; then
    root="$d/local"
    . "$root/install"
    root="$d"
elif [ -f "$root/local/install" ]; then
    warn "found a local/install, but it wasn't marked as executable; skipping"
else
    skip "didn't find a local/install"
fi
echo


# === Finish ===========================================================================
# reminders for manual bits i've not automated yet
echo
echo "$(info-col DONE). remember to do these too:"
echo "* do any machine-specific setup in local/{gitconfig,bash/*,vim/*} (then run again)"
echo "* set the user.name & user.email for this repo correctly"

if [[ $(tmux -V) =~ ^tmux\ (0\.|1\.|2\.|3\.0) ]]; then
    echo
    warn "your tmux is too old to understand \$XDG_CONFIG_HOME."
    echo "      best thing is to make local/bash/tmux.bash, with this line:"
    echo
    echo 'alias tmux="tmux -f ${XDG_CONFIG_HOME:-$HOME/.config}/tmux/tmux.conf"'
fi
