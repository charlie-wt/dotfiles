#!/usr/bin/env bash

# install all the repo contents, & some other machine setup. aims to be idempotent.


# === Basic setup ======================================================================
d=$(dirname "$(readlink -e "$0")")  # directory of this script
root="$d"
source "$root/bash/_utils.bash"

# -y or -n options to always pick yes/no at prompts
default_choice=""
if [ "$1" = "-y" ]; then
    default_choice=true
elif [ "$1" = "-n" ]; then
    default_choice=false
fi


# === Symlinking dotfiles ==============================================================
# wrapper around `symlink`, specifically for dotfiles.
#
# $1: name of the file to link to (relative to $root).
# $2: (optional) name of symlink (absolute path). defaults to ~/.$1.
dotfile () {
    # params
    local dotfile_name="$1"
    local link_name="${2:-$HOME/.$dotfile_name}"

    symlink "$root/$dotfile_name" "$link_name" "dotfile $dotfile_name"
    return $?
}

title "symlinking dotfiles..."
dotfile bashrc
dotfile gdbinit
dotfile gitconfig       "$(config-home)/git/config"
dotfile kitty.conf      "$(config-home)/kitty/kitty.conf"
dotfile bash_profile
dotfile tmux.conf       "$(config-home)/tmux/tmux.conf"
dotfile vimrc
dotfile inputrc         "$(config-home)/readline/inputrc"
echo


# === Install scripts ==================================================================
# wrapper around `symlink`, specifically for scripts.
#
# $1: name of file to link to (relative to $root/scripts).
# $2: (optional) installed name of the script. defaults to that of the linked-to file.
install-script () {
    # params
    local script_path="$1"
    local script_name="${2:-$(basename "$script_path")}"

    local target="$root/scripts/$script_path"
    local link_name="$(bin-home)/$script_name"

    symlink "$target" "$link_name" "$script_path script"

    res=$?
    [ $res -eq 2 ] && >&2 echo "(looking in $root/scripts for scripts; have you set \$root correctly?)"
    return $res
}

title "symlinking scripts..."
install-script branched-from
install-script lightdark
install-script submods
install-script update-clangd
install-script update-kitty
install-script update-vim
echo


# === Other symlinks ===================================================================
title "making other symlinks..."
[ -d "$root/vim" ] && symlink "$root/vim" "$HOME/.vim/personal" "vim personal dir"
echo


# === Other bits =======================================================================
title "doing other misc stuff..."

# make directories for vim swapfiles, backups etc.
mkdir -p "$(state-home)/vim/backups"
mkdir -p "$(state-home)/vim/sessions"
mkdir -p "$(state-home)/vim/swaps"
mkdir -p "$(state-home)/vim/undo"

# basic setup for vim plugin manager
vim_plug_loc="$HOME/.vim/autoload/plug.vim"
if [ -e "$vim_plug_loc" ]; then
    skip "plug.vim already exists in $vim_plug_loc"
else
    curl -fLo "$vim_plug_loc" --create-dirs \
        https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
    vim -c 'PlugInstall' -c 'qa!'
fi

# setup tmux plugin manager
tpm_dir="$(config-home)/tmux/plugins/tpm"
if [ -e "$tpm_dir" ]; then
    skip "tpm already exists in $tpm_dir"
else
    git clone https://github.com/tmux-plugins/tpm "$tpm_dir"
    . "$tpm_dir"/bin/install_plugins
fi

# return 0 if an apt package is installed, else 1. will return 2 if apt isn't installed.
# $1: name of apt package to check.
is-apt-installed () {
    if ! have-cmd apt ; then
        return 2  # error
    fi
    local installed="$(apt list --installed "$1" 2>/dev/null | grep -v "^Listing" | wc -l)"
    if [ "$installed" -ge 1 ]; then
        return 0  # yes
    fi
    return 1  # no
}
if is-apt-installed rustc; then
    if confirm-action "$(warn-col rustc installed via apt): uninstall, to get via rustup instead?"; then
        sudo apt remove -y rustc
    fi
fi

# maybe install apt package
# $1: name of package to install
apt-install () {
    local installed="$(exit-code is-apt-installed "$1")"
    if [ "$installed" = 2 ]; then
        skip "apt not installed to install $1"
    elif [ "$installed" = 0 ]; then
        skip "$1 already installed"
    elif [ "$installed" = 1 ]; then
        confirm-action "install $(info-col "$1") (via apt)?" && sudo apt install -y "$1"
    else
        error "unknown error when apt installing $1 (is-apt-installed returned $installed)"
        return 1
    fi
}
apt-install python-is-python3
apt-install python3-pip  # note: needed for the later pipx stuff
apt-install python3-venv
apt-install tmuxinator

# basic rust setup
rustup_dir="$(data-home)/rustup"
cargo_dir="$(data-home)/cargo"
if [[ -e "$rustup_dir" && -e "$cargo_dir" ]]; then
    skip "rustup & cargo already exist in $rustup_dir & $cargo_dir"
elif confirm-action "do you want to install rust & cargo, via rustup?"; then
    export RUSTUP_HOME=$rustup_dir
    export CARGO_HOME=$cargo_dir
    curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y --no-modify-path
fi

# if a cargo package isn't installed globally, ask to install it
# $1: cargo package name
cargo-install () {
    if ! have-cmd cargo; then
        skip "cargo not installed to install $1"
    elif [ -n "$(cargo install --list | grep "^$1\s")" ]; then
        skip "$1 already installed"
    else
        confirm-action "install $(info-col "$1") (via cargo)?" && cargo install "$1"
    fi
}
cargo-install fd-find
cargo-install ripgrep

# pipx
# TODO #bug: doesn't want to install somehow
if have-cmd pipx; then
    skip "pipx already installed"
elif have-cmd pip && confirm-action "install pipx?"; then
    PIP_BREAK_SYSTEM_PACKAGES=1 pip install --user pipx
fi

# if a pipx package isn't installed globally, ask to install it
# $1: pypi package name
pipx-install () {
    # TODO #bug: i think if pip was installed in this terminal session, `pip.bash` won't
    # have run to update the $PATH so `have-cmd pipx` will continue to fail. maybe
    # should put all the $PATH-updating stuff in `bash/` before the various guards...
    if ! have-cmd pipx; then
        skip "pipx not installed to install $1"
    elif [ -n "$(pipx list --short 2>/dev/null | grep "^$1\s")" ]; then
        skip "$1 already installed"
    else
        confirm-action "install $(info-col "$1") (via pipx)?" && pipx install "$1"
    fi
}
pipx-install python-lsp-server
pipx-install ranger-fm

# micromamba
micromamba="$(data-home)/micromamba/micromamba"
chosen_not_to_install_micromamba=0
# install micromamba if desired.
# NOTE: if not installed, and user chose not to install, will set
# `chosen_not_to_install_micromamba` to 1.
# $1: (optional) reason
verify-micromamba-installed () {
    [ -x "$micromamba" ] && return 0  # don't print, since this may run many times
    [ $chosen_not_to_install_micromamba = 1 ] && return 1

    local reason_str="$1"
    [ -n "$reason_str" ] && reason_str=" (for $(info-col "$reason_str"))"

    if confirm-action "install micromamba$reason_str?"; then
        mkdir -p "$(dirname "$micromamba")"
        echo "about to install micromamba; use the following options $(warn-col "(but choose a real, explicit home path!)"):"
        echo "Micromamba binary folder? [~/.local/bin] $(info-col "/path/to/personal/home/.local/share/micromamba")"
        echo "Init shell (bash)? [Y/n] $(info-col "n")"
        echo "Configure conda-forge? [Y/n] $(info-col "y")"
        "${SHELL}" <(curl -L micro.mamba.pm/install.sh)
    else
        chosen_not_to_install_micromamba=1
        return 1
    fi
}

# standardised directory for micromamba wrapper scripts. is a function to be responsive
# to changes to $root.
mamba-wrappers-dir () {
    echo "$root/.mamba-wrappers"
}

# make a wrapper script for a micromamba bin in a specified directory.
# $1: binary name
micromamba-wrap () {
    # check we have the chosen binary (fail silently if not)
    local env_dir="$("$micromamba" env list | grep -w global | awk '{print $2}')"
    [ -f "$env_dir/bin/$1" ] || return 1

    # ensure we have the wrapper script dir
    [ -d "$(mamba-wrappers-dir)" ] || mkdir -p "$(mamba-wrappers-dir)"

    # make the wrapper script, if needed (assume if the file exists, it's correct)
    if ! [ -f "$(mamba-wrappers-dir)/$1" ]; then
        printf "#!/usr/bin/env bash
[ -z \"\$MAMBA_EXE\" ] && >&2 echo \"\\\$MAMBA_EXE not set\" && exit 1
\"\$MAMBA_EXE\" run -n global $1 \$@
" > "$(mamba-wrappers-dir)/$1"
    fi
    chmod u+x "$(mamba-wrappers-dir)/$1"

    symlink "$(mamba-wrappers-dir)/$1" "$(bin-home)/$1" "$1 micromamba wrapper script"
}

# if a micromamba package isn't installed 'globally', ask to install it (& create a
# wrapper script to put directly in $PATH)
# $1: conda-forge package name
# all args after `--`: binaries to wrap up (if no `--`, try one matching package name)
micromamba-install () {
    verify-micromamba-installed "$1"  # (don't exit here, to pick up the `skip` msg below)

    if ! [ -x "$micromamba" ] && [ $chosen_not_to_install_micromamba = 1 ] ; then
        skip "micromamba not installed to install $1"
        return 0
    fi

    # get list of binaries to wrap (handle `--`)
    local to_wrap=("$1")
    local seen=0
    local before_args=()
    local after_args=()
    for arg in "$@"; do
        if [ "$seen" = 0 ]; then
            if [ "$arg" = "--" ]; then
                seen=1
            else
                before_args+=("$arg")
            fi
        else
            after_args+=("$arg")
        fi
    done
    [ "${#after_args[@]}" -gt 0 ] && local to_wrap="${after_args[@]}"

    # install package
    "$micromamba" env list | grep "^\s*global\s" -q
    local have_global_env="$?"
    if [ "$have_global_env" = 0 ] && "$micromamba" list -n global | grep "^\s*$1\s" -q; then
        skip "$1 already installed"
    elif confirm-action "install $(info-col "$1") (via micromamba)?"; then
        [ "$have_global_env" = 1 ] && "$micromamba" create -n global
        "$micromamba" install -n global "$1"
    fi

    # make any necessary wrapper scripts
    for b in ${to_wrap[@]} ; do micromamba-wrap "$b" ; done
}

# (don't need to `micromamba install` anything here, but make functions available for
# local installs)

# kitty theme
kitty_theme_dest="$(config-home)/kitty/theme.conf"
if [ ! -e "$kitty_theme_dest" ]; then
    symlink "$root/other/gruvbox/kitty/dark.conf" "$kitty_theme_dest" "kitty theme"
fi

# pre-commit hooks for this repo
install-hooks () {
    local hook_script="$root/.git/hooks/pre-commit"
    local contents=(
        '#!/usr/bin/env bash'
        'for f in $(find "hooks/pre-commit" -maxdepth 1 -type f) ; do . "$f" ; done'
    )
    printf "%s\n" "${contents[@]}" > "$hook_script"
    chmod u+x "$hook_script"
}
install-hooks

# TODO #enhancement: custom bash completions?
echo


# === Local ============================================================================
title "doing local install..."

if [ -x "$root/local/install" ]; then
    root="$d/local"
    . "$root/install"
    root="$d"
elif [ -f "$root/local/install" ]; then
    warn "found a local/install, but it wasn't marked as executable; skipping"
else
    skip "didn't find a local/install"
fi
echo


# === Finish ===========================================================================
# reminders for manual bits i've not automated yet
echo
echo "$(info-col DONE). remember to do these too:"
echo "* do any machine-specific setup in local/{gitconfig,bash/*,vim/*} (then run again)"

if [[ $(tmux -V) =~ ^tmux\ (0\.|1\.|2\.|3\.0) ]]; then
    echo
    warn "your tmux is too old to understand \$XDG_CONFIG_HOME."
    echo "      best thing is to make local/bash/tmux.bash, with this line:"
    echo
    echo 'alias tmux="tmux -f ${XDG_CONFIG_HOME:-$HOME/.config}/tmux/tmux.conf"'
fi
